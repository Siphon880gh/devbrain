Aka **process managers** or **process supervisors**: They automatically manage processes, ensuring that your applications stay running, and can restart them if they crash or if the server is rebooted. Usually you can also control if there are cloned instances listening to the same port for more CPU bound resources or you can leverage multithreads. This functionality makes them ideal for maintaining long-running applications and services.

The process supervisor you use depends on the language of your server or script:
- With NodeJS apps, we usually use pm2 to manage the express server at server.js. You may manage them using pm2 commands or using a pm2 ecosystems file. The PM2 can support cloning instances of the process listening to the same port, in a mechanism called cluster, but does NOT support multithreading. Multithreading needs to be at the app's code level which is supported on newer versions of NodeJS.
- For python, we usually architecture the Flask app (server.py) to have a **WSGI** entry point (wsgi.py) that gunicorn communicates with, and gunicorn can manage both cloning instances of the process listening to the same port, in a mechanism called worker processes, and can also support multithreading. However for 24/7 persistence and supervision, you need to use a linux daemon called Supervisor. For Supervisor to run gunicorn cli with the options, you'll need a .sh shell file that Supervisor communicates with. Supervisor also has a central config file and specific app config files to control other settings like autostarting and logging file path.