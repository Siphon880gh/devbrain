
Manifest.json's "content_scripts" section lets you add zero or more content js and zero or more content css which Chrome looks for in order to know what logic to affect the webpage and what styles to apply. The "content_scripts" section matches against URLs to know when to apply as soon as the webpage is finished loading (if you've set the lifecycle at "content_scripts" to the end). You can choose to skip the css by not including a css property at "content_scripts". Most often the use is for javascript.

Key takeaway:
- No need to click the Chrome Extension icon to run.
- Running starts as soon as it detects a webpage matches one of the URLs you define at manifest.json, as long as the Chrome Extension is installed and enabled.
- The code are located in content.js and you can have dependencies like jquery by having additional js files you load into content_scripts. Libraries must be local (CDN not allowed in manifest v3). Have the dependencies listed first at "content_scripts".js.

---

Setup the files from [[2a. Chrome extension foundational with popup]] with some variation (refer below).

Create manifest.json among other files including content.js to modify/read from any visited website that matched a url pattern (no need to click Chrome Extension)

>[!note] File Structure
>Bare minimum example:
>- icon files `<will work on>`
>- manifest.json
>- content.js
> 
### manifest.json

#### manifest.json Overview

manifest.json for content js (for reading/modifying from webpage):

manifest.json for a popup (for learning foundations):
- Manifest version 3.
- Include your app name, version and description (affects Chrome extension store) and icons to show on the web browser pinned extensions area, the Google chrome extension store, etc.
- Includes Content Security Policy rules which is permission and scoping.
- We added a content script section for the content reading/modifying. We'll go more into details at a later section, but briefly it matches domains to apply the injections to, and it points to content js file to inject and optionally a content css file to inject (to change appearance of the webpage), and finally a lifecycle to inject at (eg. document_idle, document_start, etc)

manifest.json:
```
{  
    "manifest_version": 3,  
    "name": "<APP_NAME>",  
    "version": "1.0",  
    "description": "<APP_DESCRIPTION>.",  
    "author": "Weng Fei Fung",
    "icons": {  
        "16": "icon16x16.png",  
        "32": "icon32x32.png",  
        "48": "icon48x48.png",  
        "128": "icon128x128.png"  
    },
    "content_security_policy": {  
        "extension_pages": "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self'; object-src 'self';"
    },
    "content_scripts": [
    {
      "matches": ["https://*/*", "http://*/*"],
      "js": ["content.js"],
      "css": ["styles.css"],
      "run_at": "document_idle"
    },
}
```
#### manifest.json CSP

You should know it by now. If you need to, review [[2b. Content Security Policy - script, style, object, img, connect, default - Foundational]].

#### manifest.json Icons

You should know how to generate or create icons by now. If you need to, review [[2b. Content Security Policy - script, style, object, img, connect, default - Foundational]]. 

If you dont have icons, the installation will fail with the error:
![[Pasted image 20250319004613.png]]

---

### manifest.json content_scripts

Please note you cannot simply link to a cdn for js files (eg. jquery) because Google has gotten strict with manifest v3. You'll have to provide your own jquery file in your extension folder. Likely you'll load multiple js files into the content_scripts in manifest.json. Have the dependencies listed first at "content_scripts".js.
#### matches

This defines **which URLs** your content script will run on. It's an array of [match patterns](https://developer.chrome.com/docs/extensions/mv3/match_patterns/), which are strings that specify URLs.

**Example values:**

- `"https://*/*"` → all HTTPS pages
- `"http://*/*"` → all HTTP pages
- `"*://*.example.com/*"` → all pages on example.com (including subdomains)
- `"*://mail.google.com/*"` → only Gmail pages
- `"*://*/*"` → all pages on any protocol (risky! use carefully)

✅ **Must include protocol** (http or https)  
❌ Cannot use wildcards in the domain _path_ (e.g., `*example.com` is invalid — use `*.example.com`)

#### Injections

- `"js"`: JavaScript file(s) to inject.
- `"css"`: CSS file(s) to inject.

Example with multiples:
```
{
  "content_scripts": [
    {
      "matches": ["https://*.example.com/*"],
      "js": ["lib/jquery.js", "helpers.js", "main.js"],
      "css": ["reset.css", "styles.css"],
      "run_at": "document_end"
    }
  ]
}
```

Examples with singulars:
```
{
  "content_scripts": [
    {
      "matches": ["https://*.example.com/*"],
      "js": "content.js",
      "css": "content.css",
      "run_at": "document_end"
    }
  ]
}

```

#### run_at

This controls **when** your content script is injected into the page:

|Value|When It Runs|Notes|
|---|---|---|
|`"document_start"`|Before the page starts loading (early as possible)|Useful for blocking/pre-loading|
|`"document_end"`|After the HTML is loaded, but before other resources (like images)|Safe for DOM manipulation|
|`"document_idle"`|After the page is fully loaded (default)|Best for waiting until everything’s ready|

If you don’t set `run_at`, Chrome uses `"document_idle"` by default.


Example:
- This injects `content.js` into all HTTPS pages on `example.com` **before the page starts loading**.
```json
{
  "matches": ["https://*.example.com/*"],
  "js": ["content.js"],
  "run_at": "document_start"
}
```

Setup content.js as:
```
console.log("Content script loaded");

  // Check if the current URL contains google.com
if (window.location.href.includes('google.com')) {
    // Show alert if Google is found
    alert('Found Google');
} 
```

Remove css property for content_scripts if still have, from manifest.

---

Update Chrome Extension and visit google.com. It should alert "Found Google".

Note there's a glitch with Chrome where if you have default settings and it's a new tab that has google opened, it won't work because technically it's not google.com, it's just Google Chrome's default tab.


![[Pasted image 20250322175233.png]]

Visiting google.com directly, THEN you'd get:
![[Pasted image 20250322175353.png]]