### tabId not needed for background actions

We can simplify background.js because some of what's needed at popup.js isn't needed because background.js has increased awareness / abilities

We can simplify background.js to:
```
console.log("background.js loaded");

// At the start of your background.js
chrome.runtime.onStartup.addListener(async () => {
  // Restore badge state from storage
  const state = await chrome.storage.local.get(['badgeState']);
  if (state.badgeState) {
    if(state.badgeState.text) {
      chrome.action.setBadgeText({
        text: state.badgeState.text
      });
    } else if(state.badgeState.color) {
      chrome.action.setBadgeBackgroundColor({
        color: state.badgeState.color
      });
    }
  }
});

chrome.runtime.onMessage.addListener(async function (request, sender, sendResponse) {
  switch (request.type) {
    case "activeTab":
      const { tabId, href } = request;

      chrome.tabs.update(tabId, { url: href }, async (tabInfo) => {
        console.log('Tab updated, waiting for load...');
        chrome.action.setBadgeText({
          text: "WAIT",
        });
        chrome.action.setBadgeBackgroundColor({
          color: "#FF0000",
        });

        // Wait for the tab to complete loading
        await new Promise((resolve) => {
          chrome.tabs.onUpdated.addListener(function listener(updatedTabId, info) {
            if (updatedTabId === tabId && info.status === 'complete') {
              chrome.tabs.onUpdated.removeListener(listener);
              resolve();
            }
          });
        });

        try {
          console.log('Attempting to change favicon...');
          await chrome.scripting.executeScript({
            target: { tabId: tabId },
            func: () => {
              console.log('Script executing in tab...');

              // Change favicon
              let link = document.querySelector("link[rel*='icon']");
              if (!link) {
                link = document.createElement('link');
                link.rel = 'shortcut icon';
              }
              link.type = 'image/x-icon';
              link.href = 'https://cdn-icons-png.flaticon.com/512/16000/16000326.png';
              document.head.appendChild(link);

              // Change title
              document.title = "ACTIVE";

              // Add visual feedback
              const notification = document.createElement('div');
              notification.id = "favicon-changed-notification";
              notification.textContent = 'Favicon changed!';
              notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 10px; border-radius: 5px; z-index: 9999;';
              document.body.appendChild(notification);
            }
          });

          console.log('notification-duration-reached before alarm created')
          // Set up alarm to clear notification and storage after 3 seconds, including the tabId
          chrome.alarms.create('notification-duration-reached', {
            delayInMinutes: 0.05, // 3 seconds
            periodInMinutes: 0
          });
          // Store the tabId for the alarm handler
          chrome.storage.local.set({ 'timerTabId': tabId });

          // When setting badge
          const text = "OK";
          const color = "#FFFFFF";
          await chrome.action.setBadgeText({text});
          await chrome.action.setBadgeBackgroundColor({color});
          const badgeState = { text, color };
          await chrome.storage.local.set({ badgeState }); // Store the state

        } catch (error) {
          console.error('Failed to execute script:', error);
          chrome.action.setBadgeText({
            text: "ERR",
          });
        }
      });
      break;
  } // switch
});

chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === 'notification-duration-reached') {
    chrome.storage.local.get(['timerTabId'], function(result) {
      const tabId = result.timerTabId;
      if (!tabId) return;

	  // Get the stored tabId instead of querying active tab
      console.log('notification-duration-reached onAlarm')
      
      // Clear the badge
      chrome.action.setBadgeText({
        text: "",
      });

      // Remove the notification
      chrome.scripting.executeScript({
        target: { tabId: tabId },
        func: () => {
          try {
            const notification = document.getElementById("favicon-changed-notification");
            if (notification) {
              notification.remove();
            }
          } catch (error) {
            console.error('Error removing notification:', error);
          }
        }
      }).catch(error => {
        console.error('Failed to execute script:', error);
      });

      // Clean up stored tabId
      chrome.storage.local.remove('timerTabId');
    })
    }
});
```

What we've done is removed all `tabId` from `chrome.action.setBadgeText` and `chrome.action.setBadgeBackgroundColor`, at: 
- at the start of background.js where it checks for any existing badge to continue re-rendering (because if background service worker restarted, then previous badge visual aborted).
- at when the badge is set to a white "OK" after a red "WAIT" and the 3 second countdown is created
- at when the 3 second countdown is reached, then the badge is set to empty text ""

We also removed `tabId` from the badgeState that's saved to Storage to keep the badge information persistent into the alarm execution context.

This is all due to background.js Chrome action having more awareness. If you were running setBadgeText or setBadgeBackgroundColor anywhere else (like popup.js), you'd needed to provide the tabId.

We CANNOT remove `tabId` from `chrome.scripting.executeScript` because manifest v3 hasn't given that awareness to background.js.

### Notifications system

Maybe replace green notification
```
chrome.notifications.create({ type: "basic", iconUrl: "icon.png", title: "active", message: "Favicon changed successfully", priority: 0 });
```

Coming soon!