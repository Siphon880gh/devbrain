
Explained how a root package.json coordinates the React client and Express server, how you need a proxy to 3001 (http://localhost:3001) from React when it's in development because otherwise fetch requests from React when in HMR / Hot Module Replacement would be relative URL requests erroneously going to port 3000 where React runs in, and how in production it's just the /server that's actively running so you need a /build folder for sendFile in GET / route, but also explaining although /build is in .gitignore - Heroku will run build script before start script so there will become a /build folder at Heroku. 

(Reworded: Proxy would have client's port 3000's relative fetch requests going to a different port 3001 and not have cors issue. This is because proxy is done in the source at package.json so it's authenticated to be the developer's intention. This is a common architecture pattern because you may be in HMR server that runs on different port. At production, the frontend file would be sendFile by the server anyways.)

Explained components as if they're custom semantic html tags that can be modularized into separate files. Explained props are as if they're custom html attributes that can pass information between components. Explained React.StrictMode that wraps around the entire app so it can provide hints and error messages instead of being more lenient. 

Explained how GraphQL works, that typedefs are like gatekeepeers because they allow only the type of information you request and get responded back for the frontend gql tag functions, explained that resolvers connect the database to the GraphQL because the resolvers implement querying the information into the response and that the model queries must return the same matching response types as defined in the typedefs; explained server.js is what links resolvers and typedefs, and that the GraphQL instance wraps around the Express server; explained that this is still a mixed express-graphql server because express is used in production to sendFile the /build/index.html while other requests are to /graphql; Explained that ApolloProvider wraps your other components / html tags, allowing them to make GraphQL queries and mutations.